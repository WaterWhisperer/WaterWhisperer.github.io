[{"title":"Why Rust is My Primary Choice?","url":"/2025/11/16/Why-Rust-is-My-Primary-Choice/","content":"When many people talk about Rust, they often repeatedly mention “memory safety.” But in my opinion, this is just the tip of the iceberg of this fascinating language.\nWhat Attracts Me to RustModern ToolchainI believe there’s an indisputable fact that languages that emerge later inherently benefit from the advancements of their predecessors. It’s precisely by building on the shoulders of giants that we can see further and go further. A fresh start is always more effective than piecemeal improvements.\nRust’s toolchain and compiler are modern and efficient. Cargo enables developers to easily perform checks, tests, and builds, allowing beginners to quickly get involved in projects. Most Rust projects can be directly built and used after being cloned from GitHub. The information provided by rustc is incredibly detailed, completely different from the cryptic “segmentation fault” errors in C&#x2F;C++ that I encountered early on. This makes it much easier for me to identify and solve problems. Honestly, this gave me the first impression that Rust might be particularly suitable for new programmers. By the way, I’ve learned a tremendous amount from the clippy linter’s suggestions.\nVibrant EcosystemIt might sound unusual to describe a programming language with the word ‘vitality’, but that’s exactly how Rust feels to me. Both the language itself and its ecosystem give me a sense of vibrancy and liveliness. Ten-year-old Rust is like the morning sun at 7 AM, full of promise and energy, or like myself just turning 20.\nLooking at this year’s Rust proposals, each one seems to directly address real pain points. Indeed, it’s remarkable that despite unresolved issues like Cargo and Rust Analyzer competing for the target directory, Rust continues to attract so many dedicated users. In terms of ecosystem, on GitHub, if you want to find projects to contribute to, I’ve found that Rust projects are among the easiest to discover, there are plenty of them, with many ‘good first issue’ labels, and both the projects and their communities are exceptionally welcoming.\nPersonal ConnectionJust as sometimes there’s no specific reason for liking someone, for me, it’s the same with a programming language. People might point out Rust’s flaws or suggest that other languages are superior, but that doesn’t change how I feel. I enjoy using Rust because of a deep sense of compatibility—it feels like the ‘right fit’ for me. This is a feeling that programming with other languages simply doesn’t provide.\nLooking ForwardI genuinely hope Rust continues to evolve and improve, that more people discover and learn Rust, and that increasingly more projects adopt this wonderful language. The future looks bright for Rust, and I’m excited to be part of this journey.\n","tags":["Rust"]},{"title":"Git Workflow for Open Source Contributions","url":"/2025/11/22/Git-Workflow-for-Open-Source-Contributions/","content":"Effective Git usage is fundamental to successful open source contributions. A well-structured workflow not only boosts productivity but also ensures clean project history and smooth collaboration with maintainers. In this article, I’ll share a Git workflow that has consistently worked well for my open source contributions.\nInitial SetupAfter forking a project on GitHub or similar platforms, the first step is to clone your forked repository to your local machine:\ngit clone https://github.com/your-username/project-name.gitcd project-name\n\nDevelopment Branch StrategyWorking directly on the main branch is discouraged as it can lead to conflicts and messy history. Instead, create a dedicated branch for your work:\ngit checkout -b feature/your-feature-name\n\nChoose descriptive branch names that clearly indicate the purpose of your work. Good examples include feature/user-authentication, fix/typo-in-readme, or docs/update-installation-guide.\nCommitting Your ChangesWhen you’ve made your changes, use git add to stage them and git commit to commit:\ngit add .git commit -m &quot;feat: add user authentication system&quot;\n\nI strongly recommend following the Conventional Commits specification for commit messages. This makes the commit history more readable and helps with automated versioning.\nWhen Your Work Gets MergedOnce your contribution is accepted and merged, it’s time to clean up your local environment:\n# Delete the local development branchgit branch -D feature/your-feature-name# Delete the remote branch (if you pushed it to your fork)git push origin --delete feature/your-feature-name# Update your main branch to stay synchronizedgit checkout maingit pull upstream main\n\nHandling Requested Changes and RebasingThis phase often challenges contributors. When maintainers request modifications or you need to rebase onto newer code, here’s an efficient approach:\nRather than accumulating multiple commits and later squashing them with interactive rebase, I prefer this streamlined workflow:\n\nFetch the latest changes:\ngit fetch --all\n\nOr more targeted:\ngit fetch upstream\n\nI prefer the targeted approach and configure my local repository to fetch only the main branch from upstream:\ngit config --edit --local\n\nAdd this configuration:\n[remote &quot;upstream&quot;]fetch = +refs/heads/main:refs/remotes/upstream/main\n\nThis configuration is efficient since most development occurs on the main branch.\n\nRebase onto the latest upstream:\ngit rebase upstream/main\n\nResolve any conflicts:\n\nAddress conflicts as they arise in your code\n\nAfter resolution, continue the rebase process:\ngit rebase --continue\n\nIf you encounter complex issues, abort and reassess:\ngit rebase --abort\n\n\nIncorporate new changes:After implementing the requested modifications, amend your existing commit rather than creating a new one:\ngit add .git commit --amend --no-edit\n\nUse --no-edit to preserve your original commit message, or omit it if you need to update the message.\n\nForce push your changes:Since rebasing rewrites commit history, you’ll need to force push:\ngit push -f\n\nFor added safety, use:\ngit push --force-with-lease\n\nThis prevents accidentally overwriting others’ work.\n\n\nBenefits of This WorkflowThis approach provides several key advantages:\n\nClean commit history: Each feature or fix remains as a single, well-structured commit\nStreamlined conflict resolution: Conflicts are addressed during rebase rather than merge\nCurrent codebase: You consistently work with the latest upstream changes\nReduced commit clutter: Avoids accumulating minor “fix typo” or “address feedback” commits\nMaintainer-friendly: Provides a clean, linear history that’s easier to review\n\nConclusionThis Git workflow has proven effective across numerous open source contributions. It maintains clean commit history, simplifies conflict resolution, and keeps your work synchronized with upstream developments. While it requires familiarity with force pushing and rebasing, the improvements in code quality and collaboration efficiency make the learning curve worthwhile.\nConsistency is crucial, so apply this workflow for each iteration of improvements until your contribution is successfully merged or the pull request is closed. With practice, this approach becomes second nature and significantly enhances your open source contribution experience.\n","tags":["Git"]}]